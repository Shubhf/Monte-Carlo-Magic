# -*- coding: utf-8 -*-
"""Monte Carlo Simulations.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11K7ez8TeC4dF8KLgBNYndX10LE6kNzC1
"""

!pip install numpy matplotlib
!pip install yfinance
!pip install quandl

"""**Necessary Importst**




"""

import numpy as np
import matplotlib.pyplot as plt

# Parameters
S0 = 100  # Initial stock price
K = 100   # Strike price
T = 1.0   # Time to maturity (1 year)
r = 0.05  # Risk-free rate
sigma = 0.2  # Volatility
num_simulations = 10000  # Number of Monte Carlo simulations
num_steps = 252  # Number of time steps (daily)

"""**Geometric Brownian Motion Simulation**"""

# Time step size
dt = T / num_steps

# Function to simulate price paths
def simulate_price_paths(S0, T, r, sigma, num_steps, num_simulations):
    price_paths = np.zeros((num_simulations, num_steps + 1))
    price_paths[:, 0] = S0

    for t in range(1, num_steps + 1):
        Z = np.random.standard_normal(num_simulations)  # Standard normal random numbers
        price_paths[:, t] = price_paths[:, t-1] * np.exp((r - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * Z)

    return price_paths

# Simulate the price paths
price_paths = simulate_price_paths(S0, T, r, sigma, num_steps, num_simulations)

"""**Option Payoff Calculation**"""

# Calculate the payoff for European call and put options
call_payoffs = np.maximum(price_paths[:, -1] - K, 0)  # Call option payoff at maturity
put_payoffs = np.maximum(K - price_paths[:, -1], 0)   # Put option payoff at maturity

"""**Discounting Payoffs to Present Value**"""

# Discount the payoffs back to present value
call_price = np.exp(-r * T) * np.mean(call_payoffs)
put_price = np.exp(-r * T) * np.mean(put_payoffs)

print(f"Call Option Price: {call_price:.2f}")
print(f"Put Option Price: {put_price:.2f}")

"""**Sensitivity Analysis**"""

# Sensitivity analysis: Varying volatility
volatilities = np.linspace(0.1, 0.5, 10)
call_prices = []

for sigma in volatilities:
    price_paths = simulate_price_paths(S0, T, r, sigma, num_steps, num_simulations)
    call_payoffs = np.maximum(price_paths[:, -1] - K, 0)
    call_price = np.exp(-r * T) * np.mean(call_payoffs)
    call_prices.append(call_price)

# Plot sensitivity analysis
plt.plot(volatilities, call_prices, marker='o')
plt.xlabel('Volatility')
plt.ylabel('Call Option Price')
plt.title('Call Option Price vs. Volatility')
plt.grid(True)
plt.show()

"""**Visualization**"""

# Plotting some simulated price paths
plt.plot(price_paths[:10].T)  # Plot first 10 paths
plt.xlabel('Time Steps')
plt.ylabel('Stock Price')
plt.title('Simulated Stock Price Paths')
plt.grid(True)
plt.show()

# Histogram of the final simulated prices
plt.hist(price_paths[:, -1], bins=50, edgecolor='black')
plt.xlabel('Final Stock Price')
plt.ylabel('Frequency')
plt.title('Distribution of Final Stock Prices')
plt.grid(True)
plt.show()